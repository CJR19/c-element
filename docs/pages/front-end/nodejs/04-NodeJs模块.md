# NodeJs模块

## 前言

Node应用由模块组成，其模块系统借鉴了 `CommonJS` 模块规范，但是并未完全按照规范实现，而是根据自身需求增加了一些特性，算是 `CommonJS` 模块规范的一个变种。

## CommonJS概述

`CommonJS` 是社区提出的一种JavaScript模块化规范，可以说是JS模块化历程中最重要的一块里程碑，它构造了一个美好的愿景——JS能够在任何地方运行，但其实由于它的模块是同步加载的，只适合在服务端等其他本地环境，并不适合浏览器端等需要异步加载资源的地方。

`为了能让JS能够在任何地方运行，CommonJS` 制定了一些接口规范，这些接口覆盖了模块、二进制、Buffer、字符集编码、I/O流、进程环境、文件系统、socket、单元测试、web服务器、网关、包管理等等，虽然大部分都处于草案阶段，但是其深深影响了Node的发展。

## CommonJS的模块规范

CommonJS的模块主要由模块引用、模块定义和模块标识三部分组成。

### 模块标识

模块标识对于每个模块来说是唯一的，是它被引用时的依据，它必须是符合**小驼峰命名**的字符串，或者是**文件的相对路径或绝对路径**。
```js
require('fs')// fs是内建模块，执行时会被直接载入内存，无须路径标识
require('./moduleA')//导入当前目录的moduleA
require('../moduleB')// 导入上一个目录的moduleB
require('C://moduleC')// 绝对路径导入moduleC
```
### 模块引用

使用`require()`来引用一个模块，这个方法接受一个模块标识作为参数，以此引入一个模块的API到当前上下文中。
```js
const fs = require('fs')// 引入内建的fs模块
```
### 模块定义

有导入自然也有导出，要将当前上下文中的方法或变量作为模块导出，需要使用内建的`module.exports`对象，它是模块导出的唯一出口。

`CommonJS` 规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的 `module.exports` 属性。

模块内容导出两种方式：

方式一：可将需要导出的变量或函数挂载到 `exports` 对象的属性上
```js
// node.js 每一个文件都是一个单独模块
// Node对获取的Javascript文件的内容进行了包装，以传入如下变量
console.log(exports, require, module, __filename, __dirname);
// 可将需要导出的变量或函数挂载到 exports 对象的属性上，
exports.name = 'luoxiaobu';
exports.age = '18'
```
方式二：使用 `module.exports` 对象整体导出一个变量对象或者函数
```js
// node.js 每一个文件都是一个单独模块
// Node对获取的Javascript文件的内容进行了包装，以传入如下变量
console.log(exports, require, module, __filename, __dirname);
let name = 'luoxiaobu';
let age = '18'
// 使用 module.exports 对象整体导出一个变量对象或者函数，
module.exports = {name,age};
```
模块的引用的方式： 按照引用模块的来源来区分

// 核心模块的引入 node自己的模块
```js
let crypto = require('crypto')

// 用户自己编写的模块引入
let aModule = require('./a.js')
// 第三方，别人实现发布的模块（其实也是其他用户编写）
let proxy = require('http-proxy');
```
CommonJS模块的特点如下：

- 每个模块具有独立的上下文，模块内的代码独立执行，不会污染全局作用域。
- 模块可以被多次加载，但是只会在第一次加载时运行，运行结果会被缓存，后续再加载相同模块会直接读取缓存结果，缓存存储在module.cache中
- 模块的加载按代码顺序执行。

## Node的模块实现

Node导入模块需要经历3个步骤：路径分析 -> 文件定位 -> 编译执行:

1. 路径分析：根据模块标识分析模块类型。
2. 文件定位：根据模块类型和模块标识符找到模块所处位置。
3. 编译执行：将文件编译成机器码执行，中间需要经过一系列转化。

模块类型分为内建模块和用户模块：

1. 内建模块:内建模块由Node提供，已经被编译成二进制执行文件，在node执行时，内建模块会被直接载入内存，因此我们可以直接引入，它的加载速度很快，因为它不需要经过文件定位和编译执行这2个步骤。
2. 文件模块：使用js或C++等编写的扩展模块，执行时需要先被编译成二进制机器码。需要经过上述三大步骤。

### 模块缓存

不管是内建模块还是文件模块，node在第一次加载后都会将结果缓存起来，下次加载相同模块时，会先从缓存中查找，如果能查找到则直接从缓存中读取，缓存的结果是模块编译和执行后的对象，是所有模块中加载最快的。

### 路径分析

路径分析依据的是模块标识符，模块标识符有以下几种类型：

- 内建模块标识，例如fs，path等，不需要编译，node运行时被直接载入内存等待导入。
- 相对路径模块标识：使用相对路径描述的文件模块
- 绝对路径模块标识：使用绝对路径描述的文件模块
- 自定义模块标识：通常是node_modules中的包，引入时也不需要写路径描述，node有一套算法来寻找，是所有模块标识中分析速度最慢的。

### 文件定位

文件定位主要包括文件扩展名分析、目录和包的处理。如果文件定位结束时都没找到任何文件，则会抛出文件查找失败的异常。

### 文件扩展名分析

由于模块标识可以不添加文件扩展名，因此Node会按.js、.json、.node的次序依次补足扩展名来尝试加载，尝试加载的过程需要调用fs模块同步阻塞式地判断文件是否存在，因此为了提高性能，可以在使用require()导入模块时，参数带上文件扩展名，这样会加快文件定位速度。

### 目录、包的处理

在分析文件扩展名时，可能得到的是一个目录，此时Node会将其作为一个包处理，用查找包的规则来查找：在当前目录下查找`package.json`，获得其中定义的`main`属性指定的文件名，以它来作为查找的入口，如果没有package.json，则默认将目录下的`index`当前默认文件名，然后依次查找`index.js`、`index.json`、`index.node`。

### 编译执行

编译和执行是模块导入的最后一个步骤，node会先创建一个Module实例，代表当前模块。它有以下属性：

- module.id 模块的识别符，通常是带有绝对路径的模块文件名。
- module.filename 模块的文件名，带有绝对路径。
- module.loaded 返回一个布尔值，表示模块是否已经完成加载。
- module.parent 返回一个对象，表示调用该模块的模块。
- module.children 返回一个数组，表示该模块要用到的其他模块。
- module.exports 表示模块对外输出的值。

通过文件定位得到的信息，Node再载入文件并编译。对于不同的文件扩展名，其载入方法也有所不同：

- .js文件：通过fs模块同步读取文件后编译执行。
- .node文件：这是C/C++编写的扩展文件，通过dlopen()方法加载。
- .json文件：通过fs模块读取后，用JSON.parse()解析返回结果。
- 其余扩展名一律当.js文件载入

每一个载入的模块都会被缓存，可以通过require.cache来查看。

## 文件加载模块

文件模块如果不加上扩展名，则在查找时会按照`.js`、`.json`、`.node`的顺序为其加上扩展名


文件模块有两种加载形式：① 按路径加载 ② 在node_modules文件中查找加载
文件模块按路径加载分为： ① 按照绝对路径加载 ② 按照相对路径加载


### 模块加载的顺序

在加载模块时先去缓存中查找，如果为查找到再进行以下情况判断。 
1. 模块有路径但没有扩展名：
按照其path先定位到对应的路径下，根据.js、.json、.node的顺序为path中的文件名加上后缀进行文件查找，如果找到则返回，如果未找到，则会将path中的文件名视为目录名进行查找，如果找到同名目录，则定位到该目录下，先去查找该目录下的package.json文件，通过JSON.parse()解析出包描述对象，再取出main属性指定的文件名进行定位。如果文件缺少扩展名，将会进入扩展名分析的步骤。如果该目录下没有package.json或者main属性指定的文件名错误，则会将index当做默认的文件名，然后依次查找index.js、index.json、index.node，如果找到则返回，如果未找到则require方法会抛出异常。 
2.  模块有路径且有扩展名
按照其path定位到对应的路径下，根据文件名查找对应的文件，如果找到则返回，如果未找到，require方法会抛出异常。 
3.  模块没有路径且没有扩展名
① 先去查找核心模块，如果不是核心模块则转到步骤②，否则返回核心模块。
② 去当前目录下的node_modules按照.js、.json、.node的顺序为模块名称加上扩展名然后去查找，如果找到则返回文件，否则将模块名称视为目录名称，在node_modules/目录名下查找package.json文件，通过JSON.parse()解析出包描述对象，再取出main属性指定的文件名进行定位。如果文件缺少扩展名，将会进入扩展名分析的步骤。如果该目录下没有package.json或者main属性指定的文件名错误，则会将index当做默认的文件名，然后依次查找index.js、index.json、index.node，如果找到则返回，如果未找到则执行步骤③
③ 去父目录中的node_modules中继续按照步骤②查找，直到根目录。如果到根目录还未找到文件，则执行步骤④。
④在全局目录查找：如果在操作系统的环境变量中设置NODE_PATH变量，并且已经将变量值设置为一个有效的磁盘目录，在使用require()方法加载模块时只指定了模块的名称而没有指定模块的路径，而且Node.js从其他路径中找不到需要被加载的模块文件时，Node.js将会从NODE_PATH变量值所指向的磁盘目录中寻找并加载模块文件。如果最终都没有找到，require()方法就会抛出异常。 
4.  模块没有路径且有扩展名
① 去当前目录的node_modules下查找该文件名，如果有则返回，如果没有则去父目录中的node_modules下查找，直至到根目录，如果仍旧未找到，则会去全局目录下查找，依旧未找到则require方法会抛出异常。 

require方法的查找策略


使用ES-Module

目前，在node中使用ES-Module属于实验性功能，从8.5开始支持，执行时需要加上--experimental-modules参数。从12.17.0 LTS开始，去掉了--experimental-modules ，现在可以通过使用.mjs文件代替.js文件或在package.json中指定 type 为 module 两种方式使用。
```json
// package.json
{ 
    "name": "esm-project", 
    "version": "1.0.0", 
    "main": "index.js", 
    "type": "module", 
    ... 
}
```
ES-Module相比于CommonJS的Module机制，最大不同是ES-Module对导出模块的变量、对象是动态引用，而且是在编译阶段暴露模块的导入接口，因此可以进行静态分析；而CommonJS-Module是运行时同步加载，且输出的是导出模块的浅拷贝。除此之外，ES-Module支持加载CommonJS-Module，而反过来则不行。

其次，Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量，这是因为ES-Module顶层this指向undefined，CommonJS模块的顶层this指向当前模块，而这些内部变量作为顶层变量能被直接使用。

CommonJS的内部变量有：

- `arguments`
- `require`
- `module`
- `exportsm`
- `__filename`
- `__dirname`

总结

- Node模块的加载是同步的，只有加载完成，才能执行后面的操作。
- 每一个文件就是一个模块，有自己的作用域。每个模块内部，module对象代表了当前模块，它的exports属性作为当前模块的导出接口。
- 导入的模块是导出模块的一个浅拷贝。